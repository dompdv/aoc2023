defmodule AdventOfCode.Day20 do
  import Enum

  # Basic parsing
  def parse_line("broadcaster -> " <> to),
    do: {:broadcaster, {:broadcaster, parse_list(to)}}

  def parse_line("%" <> l), do: parse_connector(l, :flipflop)
  def parse_line("&" <> l), do: parse_connector(l, :conj)

  def parse_list(to),
    do: to |> String.split(",", trim: true) |> map(&String.trim/1) |> map(&String.to_atom/1)

  def parse_connector(l, t) do
    [from, to] = String.split(l, "->", trim: true)
    {from |> String.trim() |> String.to_atom(), {t, parse_list(to)}}
  end

  def parse(args) do
    args
    |> String.split("\n", trim: true)
    |> map(&parse_line/1)
    |> then(fn l -> [{:button, {:button, [:broadcaster]}} | l] end)
    |> into(%{})
  end

  ## Create an initial state
  ## Conj nodes need to identify their predecessors

  # Find predecessors
  def find_predecessors(graph) do
    # Loop through the graph, and for each node
    # (p_map is the map %{node => [predecessor]})
    reduce(graph, %{}, fn {k, {_, l}}, p_map ->
      # Loop through the list of successors and update the predecessors map
      reduce(l, p_map, fn e, p -> Map.put(p, e, [k | Map.get(p, e, [])]) end)
    end)
  end

  # Reset the state of all nodes
  def inital_state(graph) do
    predecessors = find_predecessors(graph)

    for {k, {t, _l}} <- graph do
      {k, if(t == :conj, do: for(p <- predecessors[k], into: %{}, do: {p, :low}), else: :off)}
    end
    |> Map.new()
  end

  def inc_signal(counter, signal, n \\ 1), do: %{counter | signal => n + counter[signal]}
  def inc_low(counter, n \\ 1), do: inc_signal(counter, :low, n)
  def inc_high(counter, n \\ 1), do: inc_signal(counter, :high, n)
  # Flip the state of a flipflop
  def flip(:on), do: :off
  def flip(:off), do: :on
  def flip(state, node), do: Map.put(state, node, flip(state[node]))

  # Send a signal to all successors
  def broadcast(signal, from, successors), do: for(to <- successors, do: {from, to, signal})

  def all_high?(l), do: not any?(Map.values(l), &(&1 != :high))

  # Execute hops until no more pulses are left
  # A pulse is a tuple {to_node, signal, from_node}
  # new pulses are generated by the hop function and added to the list of pulses
  # Returns a tuple {new_state, new_counter}

  # No more pulse to process
  def hop(_, [], state, counter, _graph, _), do: {state, counter}

  def hop(i, [{from_node, to_node, signal} | pulses], state, counter, graph, prx) do
    counter =
      if to_node == prx and signal == :high do
        cycles = Map.get(counter, :cycles, %{})
        Map.put(counter, :cycles, Map.put(cycles, from_node, i))
      else
        counter
      end

    counter = if to_node == :rx and signal == :low, do: Map.put(counter, :rx, true), else: counter
    node_state = state[to_node]
    {node_type, successors} = Map.get(graph, to_node, {nil, nil})
    # number of successors: will be needed to count the number of signals sent when broadcasting
    ns = if successors == nil, do: 0, else: length(successors)

    {new_pulses, updated_state, updated_counter} =
      cond do
        # button, send a low signal to :broadcaster and increment the low counter
        node_type == :button ->
          {[{:button, :broadcaster, :low}], state, inc_low(counter)}

        # broadcaster, transmit the signal to all successors and increment the signal counter
        node_type == :broadcaster ->
          {broadcast(signal, to_node, successors), state, inc_signal(counter, signal, ns)}

        # end node, stop the signal
        node_state == nil ->
          {[], state, counter}

        # flipflop receiving a high signal: do nothing
        node_type == :flipflop and signal == :high ->
          {[], state, counter}

        # flipflop receiving a low signal: send a high signal if flipflop on off, a low if flipflop on on, and flip the flipflop
        node_type == :flipflop ->
          signal_to_send = if node_state == :off, do: :high, else: :low

          {broadcast(signal_to_send, to_node, successors), flip(state, to_node),
           inc_signal(counter, signal_to_send, ns)}

        # conj
        node_type == :conj ->
          # update node memory
          new_node_state =
            Map.put(node_state, from_node, signal)

          new_state = Map.put(state, to_node, new_node_state)

          # if all inputs are high, send a low signal to all successors, else send a high signal
          if all_high?(new_node_state),
            do: {broadcast(:low, to_node, successors), new_state, inc_low(counter, ns)},
            else: {broadcast(:high, to_node, successors), new_state, inc_high(counter, ns)}
      end

    # Add new_pulses to the list of pulses and continue
    hop(i, pulses ++ new_pulses, updated_state, updated_counter, graph, prx)
  end

  def initial_pulse(), do: [{:elve, :button, :low}]

  def part1(args) do
    graph = args |> parse()
    # Press the Button 1000 times, retaining state and counter between each press
    reduce(
      1..1000,
      {inital_state(graph), %{low: 0, high: 0}},
      fn i, {state, counter} -> hop(i, initial_pulse(), state, counter, graph, nil) end
    )
    |> then(fn {_state, counter} -> counter[:low] * counter[:high] end)
  end

  def loop_until_machine_starts(i, state, counter, graph, prx) do
    if rem(i, 1_000_000) == 0, do: IO.inspect(i)
    {new_state, new_counter} = hop(i, initial_pulse(), state, counter, graph, prx)
    cycles = Map.get(new_counter, :cycles, %{})

    if map_size(cycles) == 4,
      do: Map.values(new_counter[:cycles]),
      else: loop_until_machine_starts(i + 1, new_state, new_counter, graph, prx)
  end

  def gcd([a, b, c, d]), do: Integer.gcd(a, Integer.gcd(b, Integer.gcd(c, d)))

  def part2(args) do
    # broadcaster -> gb, ht, vk, zz
    graph = args |> parse()
    predecessors = find_predecessors(graph)
    [prx] = predecessors[:rx]

    cycles =
      loop_until_machine_starts(1, inital_state(graph), %{low: 0, high: 0, rx: false}, graph, prx)

    round(product(cycles) / gcd(cycles))
  end
end
